generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "postgresql"
}

enum Role {
  CLIENT
  EMPLOYEE
  ADMIN
}

model User {
  id           String  @id @default(uuid())
  email        String  @unique
  passwordHash String
  roles        Role[]  @default([CLIENT])
  isActive     Boolean @default(true)
  isDeleted    Boolean @default(false)

  firstName    String?
  lastName     String?
  phone        String?
  birthDate    DateTime?
  addressLine1 String?
  addressLine2 String?
  city         String?
  country      String?
  postalCode   String?

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  sessions             UserSession[]
  passwordResets       PasswordResetToken[]
  identityVerification UserIdentityVerification?
  beneficiaries        Beneficiary[]
  beneficiaryUsage BeneficiaryUsage[]
  remittances Remittance[]
}

model UserSession {
  id               String    @id @default(uuid())
  userId           String
  refreshTokenHash String
  revokedAt        DateTime?
  expiresAt        DateTime
  createdAt        DateTime  @default(now())
  updatedAt        DateTime  @updatedAt

  user User @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@index([userId])
  @@index([expiresAt])
}

model PasswordResetToken {
  id        String    @id @default(uuid())
  userId    String
  tokenHash String    @unique
  expiresAt DateTime
  usedAt    DateTime?
  createdAt DateTime  @default(now())

  user User @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@index([userId])
  @@index([expiresAt])
}

enum IdentityStatus {
  UNVERIFIED
  PENDING
  VERIFIED
  REJECTED
}

enum DocumentType {
  ID_CARD
  PASSPORT
  DRIVER_LICENSE
}

model UserIdentityVerification {
  id             String         @id @default(uuid())
  userId         String         @unique
  status         IdentityStatus @default(UNVERIFIED)
  documentType   DocumentType?
  documentNumber String?
  fullName       String?
  birthDate      DateTime?
  country        String?
  city           String?
  addressLine1   String?

  documentFrontUrl String? // Para MVP: guardamos URLs (el cliente sube a storage y nos pasa links)
  documentBackUrl  String?
  selfieUrl        String?

  reviewedAt      DateTime?
  reviewedById    String?
  rejectionReason String?
  createdAt       DateTime  @default(now())
  updatedAt       DateTime  @updatedAt

  user User @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@index([status])
}

enum BeneficiaryRelationship {
  FAMILY
  FRIEND
  BUSINESS
  OTHER
}

model Beneficiary {
  id                   String                   @id @default(uuid())
  ownerUserId          String
  fullName             String
  phone                String
  email                String?
  country              String
  city                 String?
  addressLine1         String
  addressLine2         String?
  postalCode           String?
  documentType         DocumentType?
  documentNumber       String
  relationship         BeneficiaryRelationship? @default(OTHER)
  deliveryInstructions String?
  isFavorite           Boolean                  @default(false)
  favoriteAt           DateTime?
  isDeleted            Boolean                  @default(false)
  deletedAt            DateTime?
  createdAt            DateTime                 @default(now())
  updatedAt            DateTime                 @updatedAt

  owner User @relation(fields: [ownerUserId], references: [id], onDelete: Cascade)
  usage BeneficiaryUsage?
  remittances Remittance[]

  @@unique([ownerUserId, documentNumber])
  @@index([ownerUserId])
  @@index([ownerUserId, isDeleted])
  @@index([ownerUserId, isFavorite])
}

model BeneficiaryUsage {
  beneficiaryId String @id
  ownerUserId   String
  timesUsed     Int    @default(0)
  lastUsedAt    DateTime?

  beneficiary Beneficiary @relation(fields: [beneficiaryId], references: [id], onDelete: Cascade)
  owner       User        @relation(fields: [ownerUserId], references: [id], onDelete: Cascade)

  @@index([ownerUserId, timesUsed])
  @@index([ownerUserId, lastUsedAt])
}

enum RemittanceStatus {
  DRAFT
  PENDING_PAYMENT
  PENDING_PAYMENT_CONFIRMATION
  PAID_SENDING_TO_RECEIVER
  SUCCESS
  PAYMENT_ERROR
  CANCELED_BY_CLIENT
  CANCELED_BY_ADMIN

  // legacy compatibility values
  SUBMITTED
  CANCELLED
  COMPLETED
}

enum TransferStatus {
  PENDING
  PROCESSING
  FAILED
  COMPLETED
}

enum Currency {
  USD
  EUR
}

enum OriginAccountType {
  ZELLE
  IBAN
  STRIPE
}

enum ReceptionMethod {
  USD_CASH
  CUP_CASH
  CUP_TRANSFER
  MLC
  USD_CLASSIC
}

enum OriginAccountHolderType {
  PERSON
  COMPANY
}

model PaymentMethod {
  id          String   @id @default(uuid())
  code        String   @unique
  name        String
  description String?
  enabled     Boolean  @default(true)
  imgUrl      String?
  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt

  remittances Remittance[]
}

model ReceptionMethodCatalog {
  id          String   @id @default(uuid())
  code        String   @unique
  name        String
  description String?
  enabled     Boolean  @default(true)
  imgUrl      String?
  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt

  remittances Remittance[]
}

model CurrencyCatalog {
  id          String   @id @default(uuid())
  code        String   @unique
  name        String
  description String?
  enabled     Boolean  @default(true)
  imgUrl      String?
  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt

  remittancesAsPayment  Remittance[] @relation("RemittanceCurrency")
  remittancesAsReceiving Remittance[] @relation("RemittanceReceivingCurrency")
  exchangeRatesFrom     ExchangeRate[] @relation("ExchangeRateFromCurrency")
  exchangeRatesTo       ExchangeRate[] @relation("ExchangeRateToCurrency")
}

model ExchangeRate {
  id             String   @id @default(uuid())
  fromCurrencyId String
  toCurrencyId   String
  rate           Decimal
  enabled        Boolean  @default(true)
  createdAt      DateTime @default(now())
  updatedAt      DateTime @updatedAt

  fromCurrency CurrencyCatalog @relation("ExchangeRateFromCurrency", fields: [fromCurrencyId], references: [id], onDelete: Restrict)
  toCurrency   CurrencyCatalog @relation("ExchangeRateToCurrency", fields: [toCurrencyId], references: [id], onDelete: Restrict)
  remittancesUsingThisRate Remittance[]

  @@index([fromCurrencyId, toCurrencyId, enabled, createdAt])
}

model Remittance {
  id            String           @id @default(uuid())
  senderUserId  String
  beneficiaryId String
  amount        Decimal
  status        RemittanceStatus @default(SUBMITTED)
  paymentMethodId String?
  receptionMethodId String?
  currencyId String?
  receivingCurrencyId String?
  originZelleEmail String?
  originIban String?
  originStripePaymentMethodId String?
  destinationCupCardNumber String?
  originAccountHolderType OriginAccountHolderType?
  originAccountHolderFirstName String?
  originAccountHolderLastName String?
  originAccountHolderCompanyName String?
  paymentDetails String?
  statusDescription String?
  exchangeRateIdUsed String?
  exchangeRateRateUsed Decimal?
  exchangeRateUsedAt DateTime?
  createdAt     DateTime         @default(now())
  updatedAt     DateTime         @updatedAt

  sender      User        @relation(fields: [senderUserId], references: [id], onDelete: Cascade)
  beneficiary Beneficiary @relation(fields: [beneficiaryId], references: [id], onDelete: Restrict)
  paymentMethod PaymentMethod? @relation(fields: [paymentMethodId], references: [id], onDelete: SetNull)
  receptionMethodCatalog ReceptionMethodCatalog? @relation(fields: [receptionMethodId], references: [id], onDelete: SetNull)
  paymentCurrency CurrencyCatalog? @relation("RemittanceCurrency", fields: [currencyId], references: [id], onDelete: SetNull)
  receivingCurrency CurrencyCatalog? @relation("RemittanceReceivingCurrency", fields: [receivingCurrencyId], references: [id], onDelete: SetNull)
  exchangeRateUsed ExchangeRate? @relation(fields: [exchangeRateIdUsed], references: [id], onDelete: SetNull)
  transfer Transfer?

  @@index([senderUserId, createdAt])
  @@index([beneficiaryId])
  @@index([paymentMethodId])
  @@index([receptionMethodId])
  @@index([currencyId])
  @@index([receivingCurrencyId])
}

model Transfer {
  id          String         @id @default(uuid())
  remittanceId String        @unique
  status      TransferStatus @default(PENDING)
  providerRef String?
  failureReason String?
  createdAt   DateTime       @default(now())
  updatedAt   DateTime       @updatedAt

  remittance Remittance @relation(fields: [remittanceId], references: [id], onDelete: Cascade)
}